// Code generated by MCHP Chatbot

import { create } from 'zustand';
import axios from 'axios';

const DEFAULT_API_URL = 'https://keepeat-backend.onrender.com';
const API_URL = process.env.EXPO_PUBLIC_BACKEND_URL?.trim() || DEFAULT_API_URL;

// --- Added interfaces from the suggested edit ---
export interface StockItem {
  id: string;
  barcode?: string;
  name: string;
  brand?: string;
  image_url?: string;
  category?: string;
  quantity?: string;
  expiry_date?: string;
  added_date: string;
  status: string;
  notes?: string;
}

export interface Stats {
  total_items: number;
  expiring_soon: number;
  expired: number;
  consumed_this_week: number;
  thrown_this_week: number;
}

// --- Main StockStore Interface and Zustand Implementation ---

interface StockStore {
  items: StockItem[];
  priorityItems: StockItem[];
  stats: Stats;
  isLoading: boolean;
  loadingCount: number;
  error: string | null;

  fetchStock: () => Promise<void>;
  fetchPriorityItems: () => Promise<void>;
  fetchStats: () => Promise<void>;
  markConsumed: (itemId: string) => Promise<void>;
  markThrown: (itemId: string) => Promise<void>;
  lookupProduct: (barcode: string) => Promise<any>;
  addItem: (item: Partial<StockItem>) => Promise<StockItem | null>;
  updateItem: (itemId: string, updates: Partial<StockItem>) => Promise<StockItem | null>;
}

export const useStockStore = create<StockStore>((set) => ({
  items: [],
  priorityItems: [],
  stats: {
    total_items: 0,
    expiring_soon: 0,
    expired: 0,
    consumed_this_week: 0,
    thrown_this_week: 0,
  },
  isLoading: false,
  loadingCount: 0,
  error: null,

  fetchStock: async () => {
    set((state) => ({ loadingCount: state.loadingCount + 1, isLoading: true, error: null }));
    try {
      const res = await axios.get(`${API_URL}/api/stock?status=active`);
      set({ items: res.data });
    } catch (err: any) {
      set({ error: err.message });
    } finally {
      set((state) => {
        const next = Math.max(0, state.loadingCount - 1);
        return { loadingCount: next, isLoading: next > 0 };
      });
    }
  },

  fetchPriorityItems: async () => {
    set((state) => ({ loadingCount: state.loadingCount + 1, isLoading: true, error: null }));
    try {
      const res = await axios.get(`${API_URL}/api/stock/priority`);
      set({ priorityItems: res.data });
    } catch (err: any) {
      set({ error: err.message });
    } finally {
      set((state) => {
        const next = Math.max(0, state.loadingCount - 1);
        return { loadingCount: next, isLoading: next > 0 };
      });
    }
  },

  fetchStats: async () => {
    set((state) => ({ loadingCount: state.loadingCount + 1, isLoading: true, error: null }));
    try {
      const res = await axios.get(`${API_URL}/api/stats`);
      set({ stats: res.data });
    } catch (err: any) {
      set({ error: err.message });
    } finally {
      set((state) => {
        const next = Math.max(0, state.loadingCount - 1);
        return { loadingCount: next, isLoading: next > 0 };
      });
    }
  },

  markConsumed: async (itemId: string) => {
    const { items, priorityItems, stats } = useStockStore.getState();
    // Optimistic update : retrait immédiat de l'item
    set((state) => ({
      items: state.items.filter((i) => i.id !== itemId),
      priorityItems: state.priorityItems.filter((i) => i.id !== itemId),
      stats: {
        ...state.stats,
        total_items: Math.max(0, state.stats.total_items - 1),
        consumed_this_week: state.stats.consumed_this_week + 1,
      },
    }));
    try {
      await axios.post(`${API_URL}/api/stock/${itemId}/consume`);
      // Rafraîchissement complet en parallèle
      const s = useStockStore.getState();
      await Promise.all([s.fetchStock(), s.fetchPriorityItems(), s.fetchStats()]);
    } catch (err: any) {
      // Rollback si erreur réseau
      set({ items, priorityItems, stats, error: err.message });
    }
  },

  markThrown: async (itemId: string) => {
    const { items, priorityItems, stats } = useStockStore.getState();
    // Optimistic update : retrait immédiat de l'item
    set((state) => ({
      items: state.items.filter((i) => i.id !== itemId),
      priorityItems: state.priorityItems.filter((i) => i.id !== itemId),
      stats: {
        ...state.stats,
        total_items: Math.max(0, state.stats.total_items - 1),
        thrown_this_week: state.stats.thrown_this_week + 1,
      },
    }));
    try {
      await axios.post(`${API_URL}/api/stock/${itemId}/throw`);
      // Rafraîchissement complet en parallèle
      const s = useStockStore.getState();
      await Promise.all([s.fetchStock(), s.fetchPriorityItems(), s.fetchStats()]);
    } catch (err: any) {
      // Rollback si erreur réseau
      set({ items, priorityItems, stats, error: err.message });
    }
  },

  lookupProduct: async (barcode: string) => {
    try {
      const res = await axios.get(`${API_URL}/api/product/${barcode}`);
      return res.data;
    } catch (err: any) {
      return null;
    }
  },

  addItem: async (item) => {
    try {
      const res = await axios.post(`${API_URL}/api/stock`, item);
      const s = useStockStore.getState();
      await Promise.all([s.fetchStock(), s.fetchPriorityItems(), s.fetchStats()]);
      return res.data;
    } catch (err: any) {
      console.error("Erreur lors de l'ajout :", err);
      return null;
    }
  },
  updateItem: async (itemId, updates) => {
    try {
      const res = await axios.put(`${API_URL}/api/stock/${itemId}`, updates);
      const s = useStockStore.getState();
      await Promise.all([s.fetchStock(), s.fetchPriorityItems(), s.fetchStats()]);
      return res.data;
    } catch (err: any) {
      set({ error: err.message });
      return null;
    }
  },
}));
